<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on djherbis</title>
    <link>https://djherbis.com/tags/golang/</link>
    <description>Recent content in Golang on djherbis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Mar 2015 14:48:31 -0400</lastBuildDate>
    
	<atom:link href="https://djherbis.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>#golang stream caching</title>
      <link>https://djherbis.com/post/fscache/</link>
      <pubDate>Sat, 28 Mar 2015 14:48:31 -0400</pubDate>
      
      <guid>https://djherbis.com/post/fscache/</guid>
      <description>djherbis/fscache      
Objective  Our Web server needs to perform an “expensive” process to create downloads. We want to cache these files so they don’t have to be generated on every request. If two or more concurrent clients ask for the same file, don’t generate it twice.  A naive cache design might look like this: 
Well the above code is pretty bad. We’re blocking all requests while the cache is being written to.</description>
    </item>
    
    <item>
      <title>#golang persistence with boltdb and djherbis/stow</title>
      <link>https://djherbis.com/post/stow/</link>
      <pubDate>Tue, 10 Mar 2015 21:55:40 -0400</pubDate>
      
      <guid>https://djherbis.com/post/stow/</guid>
      <description>djherbis/stow      
I like the simplicity behind boltdb however constantly converting your structs to and from an []byte can introduce a lot of extra code.
So I created stow. Stow wraps a bucket in your boltdb database so that it works a little bit more like a map.
Stow can use any encoding for storing your data, which will be transparently encoded/decoded when you Put, Get or Pull from your Store.</description>
    </item>
    
  </channel>
</rss>